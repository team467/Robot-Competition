package frc.robot.sensors;

import edu.wpi.first.hal.FRCNetComm.tResourceType;
import edu.wpi.first.hal.HAL;
import edu.wpi.first.wpilibj.Counter;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DigitalOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.SendableBase;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SendableBuilder;

import java.util.ArrayList;
import java.util.List;

/**
 * Ultrasonic rangefinder class. The Ultrasonic rangefinder measures absolute distance based on the
 * round-trip time of a ping generated by the controller. These sensors use two transducers, a
 * speaker and a microphone both tuned to the ultrasonic range. A common ultrasonic sensor, the
 * Daventech SRF04 requires a short pulse to be generated on a digital channel. This causes the
 * chirp to be emitted. A second line becomes high as the ping is transmitted and goes low when the
 * echo is received. The time that the line is high determines the round trip distance (time of
 * flight).
 */
public class DualUltrasonic extends SendableBase implements PIDSource  {

  // Time (sec) for the ping trigger pulse.
  private static final double PING_TIME = 10 * 1e-6;
  private static final double SPEED_OF_SOUND_IN_INCHES_PER_SECOND = 1130.0 * 12.0;
  private static final double MILLIMETERS_PER_INCH = 25.4;

  // ultrasonic sensor list
  private static final List<DualUltrasonic> transmitSensors = new ArrayList<>();

  // automatic round robin mode
  private static boolean automaticEnabled;
  private boolean allocatedChannels;
  private boolean enabled;
  private Counter leftCounter;
  private Counter rightCounter;

  // task doing the round-robin automatic sensing
  private static Thread task;
  private Units units;
  private static int instances;
  protected PIDSourceType pidSource = PIDSourceType.kDisplacement;

  private DigitalOutput leftPingChannel;
  // This channel shall be taped over so that it doesn't send the ping
  private DigitalOutput rightPingChannel;

  private DigitalInput leftEchoChannel;
  private DigitalInput rightEchoChannel;

  private double leftSensorDistanceToRobotCenter;
  private double distanceBetweenSensors;

  private double vertical;
  private double horizontal;
  private double angle;
  private double range;

  /**
   * Create an set of Ultrasonic Sensor instances. This is designed to supchannel the 
   * Daventech SRF04 and Vex ultrasonic sensors.
   * 
   * @param leftPingChannel The digital output channel that sends the pulse to initiate the sensor
   *                    sending the ping. Assumes left side is used for pinging
   * @param rightPingChannel the right output channel is required so that the right side will 
   *                    listen.
   * @param leftEchoChannel The digital input channel that receives the echo. The length of time 
   *                    that the echo is high represents the round trip time of the ping, and the
   *                    distance.
   * @param rightEchoChannel The digital input channel that receives the echo. The length of time 
   *                    that the echo is high represents the round trip time of the ping, and the
   *                    distance.
   * @param leftSensorDistanceToRobotCenter the horizontal distance along the robot side
   * @param rightSensorDistanceToRobotCenter the horizontal distance along the robot side
   * @param units       The units returned in either inches or millimeters
   */
  public DualUltrasonic(
      int leftPingChannel,
      int rightPingChannel,
      int leftEchoChannel,
      int rightEchoChannel,
      double leftSensorDistanceToRobotCenter,
      double rightSensorDistanceToRobotCenter,
      Units units) {
    this.leftSensorDistanceToRobotCenter = leftSensorDistanceToRobotCenter;
    distanceBetweenSensors = leftSensorDistanceToRobotCenter + rightSensorDistanceToRobotCenter;
    vertical = 0.0;
    horizontal = 0.0;
    range = 0.0;
    angle = 0.0;
    this.leftPingChannel = new DigitalOutput(leftPingChannel);
    this.rightPingChannel = new DigitalOutput(rightPingChannel);
    this.leftEchoChannel = new DigitalInput(leftEchoChannel);
    this.rightEchoChannel = new DigitalInput(rightEchoChannel);
    addChild(this.leftPingChannel);
    addChild(this.rightPingChannel);
    addChild(this.leftEchoChannel);
    addChild(this.rightEchoChannel);
    allocatedChannels = true;
    this.units = units;
    initialize();
  }

  /**
   * Gets the distance vertically from the robot's side to the detected object. 
   * If there is no valid value yet, i.e. at least one measurement hasn't completed, then return 0.
   * 
   * @return double Vertical Range in inches of the target returned from the ultrasonic sensor.
   */
  public double range() {
    return range;
  }

  public double angle() {
    return angle;
  }

  public double verticalDistance() {
    return vertical;
  }

  /**
   * Gets the distance horizontally from the center of the robot's side to the detected object.
   * 
   * @return double the distance in inches
   */
  public double horizontalFromRobotCenter() {
    return horizontal;
  }

  /**
   * Discussion of using two ultrasounds to get x and y coordinates to target.
   *
   * <p>d1 (b) = distance from sensor A to target C
   * d2 (a) = distance from sensor B to target C
   * 
   * <p>Heron's Formula
   * Area of trianble ABC is sqrt(s(s-a)(s-b)(s-c))
   * where
   *    c = c1 + c2
   *    s = (a+b+c) / 2
   * 
   * <p>height = (Area * 2) / c
   * Distance from sensor 1 to height line: c1 = sqrt(b^2 - h^2)
   * Distance from sensor 1 to height line: c2 = sqrt(a^2 - h^2)
   * 
   * <p>c2 = c - c1
   * d1 = (speed-of-sound * time) / 2
   * d2 = (speed-of-sound * time) - d1
   */
  public void periodic() {
    if (validRange()) {
      double leftDistance = leftCounter.getPeriod() * SPEED_OF_SOUND_IN_INCHES_PER_SECOND / 2.0;
      double rightDistance 
          = rightCounter.getPeriod() * SPEED_OF_SOUND_IN_INCHES_PER_SECOND - leftDistance;
      double svar = (leftDistance + rightDistance + distanceBetweenSensors) / 2;
      double area = Math.sqrt(svar * (svar - leftDistance) 
          * (svar - rightDistance) * (svar - distanceBetweenSensors));
      vertical = 2.0 * area / distanceBetweenSensors;
      horizontal = Math.sqrt((leftDistance * leftDistance) - (vertical * vertical)) 
          - leftSensorDistanceToRobotCenter;
      angle = Math.atan2(vertical, horizontal);
      range = Math.sqrt(vertical * vertical + horizontal * horizontal);
      if (units == Units.Millimeters) {
        range *= MILLIMETERS_PER_INCH;
        vertical *= MILLIMETERS_PER_INCH;
        horizontal *= MILLIMETERS_PER_INCH;
      }
    } else {
      vertical = 0.0;
      horizontal = 0.0;
      range = 0.0;
      angle = 90.0;
    }
  }

  /**
   * The units to return when PIDGet is called.
   */
  public enum Units {
    /**
     * Use inches for PIDGet.
     */
    Inches,
    /**
     * Use millimeters for PIDGet.
     */
    Millimeters
  }

  /**
   * Background task that goes through the list of ultrasonic sensors and pings each one in turn.
   * The counter is configured to read the timing of the returned echo pulse.
   *
   * <p><b>DANGER WILL ROBINSON, DANGER WILL ROBINSON:</b> This code runs as a task and assumes that
   * none of the ultrasonic sensors will change while it's running. If one does, then this will
   * certainly break. Make sure to disable automatic mode before changing anything with the
   * sensors!!
   */
  private static class UltrasonicChecker extends Thread {
    @Override
    public synchronized void run() {
      int sensorIndex = 0;
      DualUltrasonic ultrasonic;
      while (automaticEnabled) {
        //lock list to ensure deletion doesn't occur between empty check and retrieving sensor
        synchronized (transmitSensors) {
          if (transmitSensors.isEmpty()) {
            return;
          }
          if (sensorIndex >= transmitSensors.size()) {
            sensorIndex = transmitSensors.size() - 1;
          }
          ultrasonic = transmitSensors.get(sensorIndex);
        }
        if (ultrasonic.enabled()) {
          // Do the ping on both so their counters start. Right shall be taped over.
          ultrasonic.leftPingChannel.pulse(PING_TIME);
          ultrasonic.rightPingChannel.pulse(PING_TIME);
        }
        if (sensorIndex < transmitSensors.size()) {
          sensorIndex++;
        } else {
          sensorIndex = 0;
        }

        Timer.delay(.1); // wait for ping to return
      }
    }
  }

  /**
   * Initialize the Ultrasonic Sensor. This is the common code that initializes the ultrasonic
   * sensor given that there are two digital I/O channels allocated. If the system was running in
   * automatic mode (round robin) when the new sensor is added, it is stopped, the sensor is added,
   * then automatic mode is restored.
   */
  private synchronized void initialize() {
    if (task == null) {
      task = new UltrasonicChecker();
    }
    final boolean originalMode = automaticEnabled;
    automaticMode(false); // kill task when adding a new sensor
    transmitSensors.add(this);

    leftCounter = new Counter(leftEchoChannel); // set up counter for this
    rightCounter = new Counter(rightEchoChannel); // set up counter for this
    addChild(leftCounter);
    addChild(rightCounter);
    // sensor
    leftCounter.setMaxPeriod(1.0);
    leftCounter.setSemiPeriodMode(true);
    rightCounter.setMaxPeriod(1.0);
    rightCounter.setSemiPeriodMode(true);
    leftCounter.reset();
    rightCounter.reset();
    enabled = true; // make it available for round robin scheduling
    automaticMode(originalMode);

    instances++;
    HAL.report(tResourceType.kResourceType_Ultrasonic, instances);
    setName("Dual Ultrasonic", leftPingChannel.getChannel());
  }

  /**
   * Destructor for the ultrasonic sensor. Delete the instance of the ultrasonic sensor by freeing
   * the allocated digital channels. If the system was in automatic mode (round robin), then it is
   * stopped, then started again after this sensor is removed (provided this wasn't the last
   * sensor).
   */
  @Override
  public synchronized void close() {
    super.close();
    final boolean wasAutomaticMode = automaticEnabled;
    automaticMode(false);
    if (allocatedChannels) {
      if (leftPingChannel != null) {
        leftPingChannel.close();
      }
      if (rightPingChannel != null) {
        rightPingChannel.close();
      }
      if (leftEchoChannel != null) {
        leftEchoChannel.close();
      }
      if (rightEchoChannel != null) {
        rightEchoChannel.close();
      }
    }

    if (leftCounter != null) {
      leftCounter.close();
      leftCounter = null;
    }

    if (rightCounter != null) {
      rightCounter.close();
      rightCounter = null;
    }

    leftPingChannel = null;
    rightPingChannel = null;
    leftEchoChannel = null;
    rightEchoChannel = null;
    synchronized (transmitSensors) {
      transmitSensors.remove(this);
    }
    if (!transmitSensors.isEmpty() && wasAutomaticMode) {
      automaticMode(true);
    }
  }

  /**
   * Turn Automatic mode on/off. When in Automatic mode, all sensors will fire in round robin,
   * waiting a set time between each sensor.
   *
   * @param enable Set to true if round robin scheduling should start for all the ultrasonic
   *                 sensors. This scheduling method assures that the sensors are non-interfering
   *                 because no two sensors fire at the same time. If another scheduling algorithm
   *                 is preferred, it can be implemented by pinging the sensors manually and waiting
   *                 for the results to come back.
   */
  public void automaticMode(boolean enable) {
    if (enable == automaticEnabled) {
      return; // ignore the case of no change
    }
    automaticEnabled = enable;

    if (enable) {
      /* Clear all the counters so no data is valid. No synchronization is
       * needed because the background task is stopped.
       */
      for (DualUltrasonic sensor : transmitSensors) {
        sensor.leftCounter.reset();
        sensor.rightCounter.reset();
      }

      // Start round robin task
      task.start();
    } else {
      // Wait for background task to stop running
      try {
        task.join();
      } catch (InterruptedException ex) {
        Thread.currentThread().interrupt();
        ex.printStackTrace();
      }

      /* Clear all the counters (data now invalid) since automatic mode is
       * disabled. No synchronization is needed because the background task is
       * stopped.
       */
      for (DualUltrasonic sensor : transmitSensors) {
        sensor.leftCounter.reset();
        sensor.rightCounter.reset();
      }
    }
  }

  /**
   * Single ping to ultrasonic sensor. Send out a single ping to the ultrasonic sensor. This only
   * works if automatic (round robin) mode is disabled. A single ping is sent out, and the counter
   * should count the semi-period when it comes in. The counter is reset to make the current value
   * invalid.
   */
  public void ping() {
    // turn off automatic round robin if pinging
    automaticMode(false); 

    // single sensor-set
    // reset the counter to zero (invalid data now)
    leftCounter.reset(); 
    rightCounter.reset(); 
    
    // do the ping to start getting a single range
    leftPingChannel.pulse(PING_TIME);
    rightPingChannel.pulse(PING_TIME);
  }

  /**
   * Check if there is a valid range measurement. The ranges are accumulated in a counter that will
   * increment on each edge of the echo (return) signal. If the count is not at least 2, then the
   * range has not yet been measured, and is invalid.
   *
   * @return true if the range is valid
   */
  public boolean validRange() {
    return leftCounter.get() > 1 && rightCounter.get() > 1;
  }

  @Override
  public void setPIDSourceType(PIDSourceType pidSource) {
    if (!pidSource.equals(PIDSourceType.kDisplacement)) {
      throw new IllegalArgumentException("Only displacement PID is allowed for ultrasonics.");
    }
    this.pidSource = pidSource;
  }

  @Override
  public PIDSourceType getPIDSourceType() {
    return pidSource;
  }

  /**
   * Get the range in the current DistanceUnit for the PIDSource base object.
   *
   * @return The range in DistanceUnit
   */
  @Override
  public double pidGet() {
    return range();
  }

  /**
   * Set the current DistanceUnit that should be used for the PIDSource base object.
   *
   * @param units The DistanceUnit that should be used.
   */
  public void distanceUnits(Units units) {
    switch (units) {

      case Millimeters:
        if (this.units == Units.Inches) {
          vertical /= MILLIMETERS_PER_INCH;
          horizontal /= MILLIMETERS_PER_INCH;
          range /= MILLIMETERS_PER_INCH;
        }
        break;

      default:
      case Inches:
        if (this.units == Units.Millimeters) {
          vertical *= MILLIMETERS_PER_INCH;
          horizontal *= MILLIMETERS_PER_INCH;
          range *= MILLIMETERS_PER_INCH;
        }
        break;
    }

    this.units = units;
  }

  /**
   * Get the current DistanceUnit that is used for the PIDSource base object.
   *
   * @return The type of DistanceUnit that is being used.
   */
  public Units distanceUnits() {
    return units;
  }

  /**
   * Is the ultrasonic enabled.
   *
   * @return true if the ultrasonic is enabled
   */
  public boolean enabled() {
    return enabled;
  }

  /**
   * Set if the ultrasonic is enabled.
   *
   * @param enable set to true to enable the ultrasonic
   */
  public void enabled(boolean enable) {
    this.enabled = enable;
  }

  @Override
  public void initSendable(SendableBuilder builder) {
    builder.setSmartDashboardType("Ultrasonic");
    builder.addDoubleProperty("Value", this::range, null);
  }
  
}
